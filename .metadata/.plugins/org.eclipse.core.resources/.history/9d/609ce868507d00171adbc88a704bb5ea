package linked;

public class LinkedList {
	
	Node head = null;
	
	public class Node{
		int data;
		Node next = null;
		
		Node(int d){
			this.data = d;
			this.next = null;
		}
		
		public void printData() {
			 System.out.println(this.data);
			}
	}
	
	public boolean add(int value) {
		Node n = new Node(value);
		if (this.head ==  null) {
			this.head = n;
		}
		else {
			Node p = head;
			while (p.next != null) {
				p = p.next;
			}
			p.next = n;
		}
		return true;
	}
	
	public boolean addFirst(int value) {
		Node p = new Node(value);
		p.next = this.head;
		this.head = p;
		return true;
	}
	
	public void printAll() {
		Node p = this.head;
		String s = "The list contains the following values: ";
		while (p != null) {
			s += p.data;
			p = p.next;
			if (p != null){
				s += "->";
			}
			else {
				s += ".";
			}
			
		}
		System.out.println(s);
	}
	
	public Node getFirst() {
		return this.head;
	}
	
	public Node get(int index) {
		Node p = this.head;
		while (p!= null && index > 0) {
			p = p.next;
			index--;
		}
		return (index > 0) ? null : p;
	}
	public Node getLast() {
		Node p = this.head;
		while (p != null && p.next != null) {
			p = p.next;
		}
		return p;
	}
	
	public Node removeFirst() {
		Node p = this.head;
		this.head = p.next;
		return p;
	}
	
	public boolean isCyclic() {
		return this.findCycle() != null;
	}
	
	public Node findCycle() {
		Node p = this.head;
		if (p.next != null)
		{
			Node q = p.next;
			while (p != null && q != null && p!= q) {
				p = p.next;
				if (q.next != null)
					q = q.next.next;
			}
			return (p == q && p != null) ? p : null;
		}
		return null;
	}
	
	public int size() {
		Node p = this.head;
		int len = 0;
		while (p != null) {
			len++;
			p = p.next;
		}
		return len;
	}
	
	public Node areOverlappingNoCycles(LinkedList list) {
		int len = this.size();
		int listLen = list.size();
		Node p = this.head;
		Node q = list.head;
		int diff = 0;
		if (len > listLen) {
			diff = len - listLen;
		}
		if (listLen > len) {
			p = list.head;
			q = this.head;
			diff = listLen - len;
		}
		while (diff > 0) {
			p = p.next;
			diff--;
		}
		return (p != q) ? null : p;
	}
	
	public Node areOverlapping(LinkedList list) {
		Node headCycle1 = this.findCycle();
		Node headCycle2 = list.findCycle();
		
		boolean hasCycle1 = headCycle1 != null;
		boolean hasCycle2 = headCycle2 != null;
		
		if (hasCycle1 != hasCycle2)
			return null;
		if (hasCycle1 == false)
			return this.areOverlappingNoCycles(list);
		Node p = headCycle1.next;
		while (p != headCycle2 && p!= headCycle1) {
			p = p.next;
		}
		return (p != headCycle2) ? null : p;
		
		
	}
}
